input {
  # TCP input for structured JSON logs
  tcp {
    port => 5000
    codec => json_lines
  }

  # UDP input for syslog
  udp {
    port => 5000
    type => "syslog"
  }

  # Beats input for Filebeat
  beats {
    port => 5044
  }
}

filter {
  # Parse JSON logs from microservices
  if [type] == "microservice" {
    json {
      source => "message"
      target => "parsed"
    }

    mutate {
      add_field => {
        "service" => "%{[parsed][service]}"
        "level" => "%{[parsed][level]}"
        "timestamp" => "%{[parsed][timestamp]}"
        "correlation_id" => "%{[parsed][correlationId]}"
        "user_id" => "%{[parsed][userId]}"
        "organization_id" => "%{[parsed][organizationId]}"
      }
    }

    # Extract trace information
    if [parsed][trace] {
      mutate {
        add_field => {
          "trace_id" => "%{[parsed][trace][traceId]}"
          "span_id" => "%{[parsed][trace][spanId]}"
          "parent_span_id" => "%{[parsed][trace][parentSpanId]}"
        }
      }
    }

    # Parse error details
    if [parsed][error] {
      mutate {
        add_field => {
          "error_type" => "%{[parsed][error][type]}"
          "error_message" => "%{[parsed][error][message]}"
          "error_stack" => "%{[parsed][error][stack]}"
        }
      }
    }
  }

  # Add GeoIP information for security analysis
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Compliance-specific parsing
  if [type] == "compliance_event" {
    mutate {
      add_field => {
        "compliance_framework" => "%{[parsed][framework]}"
        "control_id" => "%{[parsed][controlId]}"
        "evidence_id" => "%{[parsed][evidenceId]}"
        "audit_status" => "%{[parsed][status]}"
      }
    }
  }

  # Security event parsing
  if [type] == "security_event" {
    mutate {
      add_field => {
        "event_type" => "%{[parsed][eventType]}"
        "risk_level" => "%{[parsed][riskLevel]}"
        "affected_resource" => "%{[parsed][resource]}"
      }
    }
  }

  # Calculate response time for HTTP requests
  if [parsed][http] {
    ruby {
      code => "
        if event.get('[parsed][http][duration]')
          event.set('response_time_ms', event.get('[parsed][http][duration]'))
        end
      "
    }
  }

  # Remove parsed field after extraction
  mutate {
    remove_field => ["parsed", "message"]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "soc-logs-%{+YYYY.MM.dd}"
    template_name => "soc-logs"
    template => "/usr/share/logstash/pipeline/elasticsearch-template.json"
    template_overwrite => true
  }

  # Send critical errors to a separate index
  if [level] == "error" or [level] == "fatal" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "soc-errors-%{+YYYY.MM.dd}"
    }
  }

  # Send compliance events to dedicated index
  if [type] == "compliance_event" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "soc-compliance-%{+YYYY.MM.dd}"
    }
  }

  # Send security events to dedicated index
  if [type] == "security_event" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "soc-security-%{+YYYY.MM.dd}"
    }
  }

  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}