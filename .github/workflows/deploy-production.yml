name: Deploy to Production

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.0.0)'
        required: true
        type: string
      skip_approval:
        description: 'Skip manual approval (emergency deployments only)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}
  NODE_VERSION: '18.x'
  PRODUCTION_NAMESPACE: soc-production

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      deploy_version: ${{ steps.version.outputs.version }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version to deploy
        id: version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.version }}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"
      
      - name: Verify version exists in staging
        run: |
          # Check if the version has been deployed to staging
          echo "Verifying version ${{ steps.version.outputs.version }} has been tested in staging..."
          # This would check deployment history or tags
      
      - name: Run security scan on version
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/auth-service:${{ steps.version.outputs.version }}'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

  approval:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment: production-approval
    if: github.event.inputs.skip_approval != 'true'
    
    steps:
      - name: Request approval
        run: |
          echo "üöÄ Production deployment requested"
          echo "Version: ${{ needs.pre-deployment-checks.outputs.deploy_version }}"
          echo "Requester: ${{ github.actor }}"
          echo "Please review and approve the deployment"

  backup-databases:
    name: Backup Production Databases
    runs-on: ubuntu-latest
    needs: approval
    environment: production
    
    steps:
      - name: Create database backups
        env:
          DB_HOST: ${{ secrets.PROD_DB_HOST }}
          DB_USERNAME: ${{ secrets.PROD_DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
          BACKUP_BUCKET: ${{ secrets.PROD_BACKUP_BUCKET }}
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          VERSION=${{ needs.pre-deployment-checks.outputs.deploy_version }}
          
          databases=("auth" "client" "policy" "control" "evidence" "workflow" "reporting" "audit" "integration" "notification" "ai")
          
          for db in "${databases[@]}"; do
            echo "Backing up soc_${db} database..."
            
            # Create backup
            PGPASSWORD=$DB_PASSWORD pg_dump -h $DB_HOST -U $DB_USERNAME -d soc_${db} \
              --format=custom --no-owner --clean --if-exists \
              > soc_${db}_${VERSION}_${TIMESTAMP}.dump
            
            # Upload to S3
            aws s3 cp soc_${db}_${VERSION}_${TIMESTAMP}.dump \
              s3://${BACKUP_BUCKET}/database-backups/${VERSION}/
            
            # Verify backup
            aws s3 ls s3://${BACKUP_BUCKET}/database-backups/${VERSION}/soc_${db}_${VERSION}_${TIMESTAMP}.dump
          done
      
      - name: Create backup manifest
        run: |
          cat > backup-manifest.json <<EOF
          {
            "version": "${{ needs.pre-deployment-checks.outputs.deploy_version }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "databases": ["auth", "client", "policy", "control", "evidence", "workflow", "reporting", "audit", "integration", "notification", "ai"],
            "backup_location": "s3://${{ secrets.PROD_BACKUP_BUCKET }}/database-backups/${{ needs.pre-deployment-checks.outputs.deploy_version }}/"
          }
          EOF
          
          aws s3 cp backup-manifest.json \
            s3://${{ secrets.PROD_BACKUP_BUCKET }}/database-backups/${{ needs.pre-deployment-checks.outputs.deploy_version }}/

  deploy-services:
    name: Deploy Services to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, approval, backup-databases]
    environment: production
    strategy:
      matrix:
        deployment_group: [1, 2, 3]
      max-parallel: 1
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.pre-deployment-checks.outputs.deploy_version }}
      
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
      
      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.PRODUCTION_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry ghcr-login-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy services group ${{ matrix.deployment_group }}
        run: |
          VERSION=${{ needs.pre-deployment-checks.outputs.deploy_version }}
          
          # Define service groups for rolling deployment
          case ${{ matrix.deployment_group }} in
            1)
              SERVICES="auth-service client-service policy-service control-service"
              ;;
            2)
              SERVICES="evidence-service workflow-service reporting-service audit-service"
              ;;
            3)
              SERVICES="integration-service notification-service ai-service frontend"
              ;;
          esac
          
          echo "Deploying services: $SERVICES"
          
          # Deploy with Helm using canary strategy
          helm upgrade --install soc-platform-${{ matrix.deployment_group }} ./helm/soc-platform \
            --namespace ${{ env.PRODUCTION_NAMESPACE }} \
            --values ./helm/soc-platform/values.yaml \
            --values ./helm/soc-platform/values.production.yaml \
            --set global.image.tag=$VERSION \
            --set global.image.registry=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }} \
            --set global.imagePullSecrets[0].name=ghcr-login-secret \
            --set-string global.env=production \
            --set global.deploymentGroup=${{ matrix.deployment_group }} \
            --set global.services="{$SERVICES}" \
            --wait \
            --timeout 15m
      
      - name: Verify deployment health
        run: |
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pods \
            -l deployment-group=${{ matrix.deployment_group }} \
            -n ${{ env.PRODUCTION_NAMESPACE }} \
            --timeout=300s
          
          # Check deployment status
          kubectl get deployments \
            -l deployment-group=${{ matrix.deployment_group }} \
            -n ${{ env.PRODUCTION_NAMESPACE }}
      
      - name: Run health checks
        run: |
          SERVICES=$(kubectl get services -l deployment-group=${{ matrix.deployment_group }} -n ${{ env.PRODUCTION_NAMESPACE }} -o jsonpath='{.items[*].metadata.name}')
          
          for service in $SERVICES; do
            echo "Checking health of $service..."
            kubectl run health-check-$service --rm -i --restart=Never \
              --image=curlimages/curl:latest \
              -- curl -f http://$service.${{ env.PRODUCTION_NAMESPACE }}.svc.cluster.local/health || echo "Health check failed for $service"
          done

  run-production-tests:
    name: Run Production Tests
    runs-on: ubuntu-latest
    needs: deploy-services
    environment: production
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.pre-deployment-checks.outputs.deploy_version }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          cd test/e2e
          npm ci
      
      - name: Run production smoke tests
        env:
          API_URL: https://api.soc-platform.com
          FRONTEND_URL: https://soc-platform.com
          TEST_ENV: production
        run: |
          cd test/e2e
          npm run test:production
      
      - name: Run synthetic monitoring tests
        run: |
          # Run synthetic tests to verify critical user journeys
          npm run test:synthetic
      
      - name: Performance testing
        run: |
          # Run basic performance tests
          npm run test:performance -- --threshold
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: production-test-results
          path: test/e2e/results/

  update-monitoring:
    name: Update Monitoring and Alerts
    runs-on: ubuntu-latest
    needs: deploy-services
    environment: production
    
    steps:
      - name: Update Datadog
        env:
          DD_API_KEY: ${{ secrets.DATADOG_API_KEY }}
          DD_APP_KEY: ${{ secrets.DATADOG_APP_KEY }}
        run: |
          VERSION=${{ needs.pre-deployment-checks.outputs.deploy_version }}
          
          # Create deployment marker
          curl -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "DD-API-KEY: ${DD_API_KEY}" \
            -H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Production Deployment",
              "text": "Deployed version '"${VERSION}"' to production",
              "priority": "normal",
              "tags": ["environment:production", "version:'"${VERSION}"'"],
              "alert_type": "info"
            }'
      
      - name: Update PagerDuty
        env:
          PAGERDUTY_TOKEN: ${{ secrets.PAGERDUTY_TOKEN }}
        run: |
          # Update maintenance window
          echo "Updating PagerDuty maintenance windows..."

  finalize-deployment:
    name: Finalize Deployment
    runs-on: ubuntu-latest
    needs: [deploy-services, run-production-tests, update-monitoring]
    if: success()
    environment: production
    
    steps:
      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ needs.pre-deployment-checks.outputs.deploy_version }}',
              environment: 'production',
              description: 'Production deployment completed',
              auto_merge: false,
              required_contexts: [],
              production_environment: true
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: 'https://soc-platform.com',
              description: 'Deployment completed successfully'
            });
      
      - name: Create release notes
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.pre-deployment-checks.outputs.deploy_version }}';
            const { data: commits } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'v1.0.0', // Previous version
              head: version
            });
            
            const changelog = commits.commits.map(c => `- ${c.commit.message}`).join('\n');
            
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: version,
              name: `Release ${version}`,
              body: `## What's Changed\n\n${changelog}\n\n**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/v1.0.0...${version}`,
              draft: false,
              prerelease: false
            });
      
      - name: Notify success
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "‚úÖ Production deployment completed successfully",
              attachments: [{
                color: 'good',
                fields: [
                  { title: 'Version', value: '${{ needs.pre-deployment-checks.outputs.deploy_version }}', short: true },
                  { title: 'Environment', value: 'Production', short: true },
                  { title: 'Deployed By', value: '${{ github.actor }}', short: true },
                  { title: 'URL', value: 'https://soc-platform.com', short: true }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [deploy-services, run-production-tests]
    if: failure()
    environment: production-rollback
    
    steps:
      - name: Configure kubectl
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
      
      - name: Rollback all deployments
        run: |
          echo "üîÑ Rolling back production deployment..."
          
          for i in 1 2 3; do
            helm rollback soc-platform-$i --namespace ${{ env.PRODUCTION_NAMESPACE }} || true
          done
      
      - name: Verify rollback
        run: |
          kubectl get deployments -n ${{ env.PRODUCTION_NAMESPACE }}
          kubectl get pods -n ${{ env.PRODUCTION_NAMESPACE }}
      
      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "‚ùå Production deployment failed and was rolled back",
              attachments: [{
                color: 'danger',
                fields: [
                  { title: 'Version', value: '${{ needs.pre-deployment-checks.outputs.deploy_version }}', short: true },
                  { title: 'Environment', value: 'Production', short: true },
                  { title: 'Initiated By', value: '${{ github.actor }}', short: true },
                  { title: 'Action Required', value: 'Investigate failure and fix before retrying', short: false }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Create incident
        env:
          PAGERDUTY_TOKEN: ${{ secrets.PAGERDUTY_TOKEN }}
        run: |
          # Create PagerDuty incident for failed deployment
          curl -X POST "https://api.pagerduty.com/incidents" \
            -H "Authorization: Token token=${PAGERDUTY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "incident": {
                "type": "incident",
                "title": "Production deployment failed - rollback initiated",
                "service": {
                  "id": "'"${{ secrets.PAGERDUTY_SERVICE_ID }}"'",
                  "type": "service_reference"
                },
                "urgency": "high"
              }
            }'