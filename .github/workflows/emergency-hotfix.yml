name: Emergency Hotfix Deployment

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to hotfix'
        required: true
        type: choice
        options:
          - 'auth-service'
          - 'client-service'
          - 'policy-service'
          - 'control-service'
          - 'evidence-service'
          - 'workflow-service'
          - 'reporting-service'
          - 'audit-service'
          - 'integration-service'
          - 'notification-service'
          - 'ai-service'
          - 'frontend'
      commit_sha:
        description: 'Commit SHA to deploy'
        required: true
        type: string
      reason:
        description: 'Reason for emergency deployment'
        required: true
        type: string
      incident_id:
        description: 'Related incident ID (if any)'
        required: false
        type: string
      skip_tests:
        description: 'Skip tests (use with extreme caution)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  validate-request:
    name: Validate Emergency Request
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.validate.outputs.proceed }}
    
    steps:
      - name: Validate inputs
        id: validate
        run: |
          # Validate commit SHA format
          if ! [[ "${{ github.event.inputs.commit_sha }}" =~ ^[a-f0-9]{40}$ ]]; then
            echo "‚ùå Invalid commit SHA format"
            exit 1
          fi
          
          # Log emergency request
          echo "üö® EMERGENCY HOTFIX REQUEST"
          echo "Service: ${{ github.event.inputs.service }}"
          echo "Commit: ${{ github.event.inputs.commit_sha }}"
          echo "Reason: ${{ github.event.inputs.reason }}"
          echo "Incident: ${{ github.event.inputs.incident_id || 'N/A' }}"
          echo "Requester: ${{ github.actor }}"
          echo "Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          echo "proceed=true" >> $GITHUB_OUTPUT
      
      - name: Create audit log
        uses: actions/github-script@v7
        with:
          script: |
            // Create an issue to track the emergency deployment
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Emergency Hotfix: ${{ github.event.inputs.service }}`,
              body: `## Emergency Deployment Request
              
              **Service**: ${{ github.event.inputs.service }}
              **Commit**: ${{ github.event.inputs.commit_sha }}
              **Reason**: ${{ github.event.inputs.reason }}
              **Incident ID**: ${{ github.event.inputs.incident_id || 'N/A' }}
              **Requested By**: @${{ github.actor }}
              **Time**: ${new Date().toISOString()}
              
              ### Checklist
              - [ ] Root cause identified
              - [ ] Fix tested locally
              - [ ] Rollback plan prepared
              - [ ] Stakeholders notified
              - [ ] Post-mortem scheduled
              
              ### Deployment Progress
              - [ ] Validation passed
              - [ ] Image built
              - [ ] Deployed to production
              - [ ] Health checks passed
              - [ ] Monitoring verified
              
              cc @soc-platform/on-call @soc-platform/leads`,
              labels: ['emergency', 'hotfix', 'production']
            });
            
            console.log(`Created tracking issue: ${issue.data.html_url}`);

  emergency-approval:
    name: Emergency Approval
    runs-on: ubuntu-latest
    needs: validate-request
    environment: emergency-approval
    
    steps:
      - name: Request approval
        run: |
          echo "‚è≥ Waiting for emergency approval..."
          echo "This deployment requires approval from on-call engineer or team lead"

  build-hotfix:
    name: Build Hotfix Image
    runs-on: ubuntu-latest
    needs: emergency-approval
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit_sha }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
          cache: 'npm'
      
      - name: Install and Build
        run: |
          npm ci
          npm run build --workspace=packages/auth-common
          npm run build --workspace=shared/contracts
          npm run build --workspace=shared/events
      
      - name: Run minimal tests
        if: github.event.inputs.skip_tests != 'true'
        run: |
          cd services/${{ github.event.inputs.service }}
          npm test -- --testPathPattern=critical || echo "‚ö†Ô∏è Some tests failed"
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push hotfix image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/${{ github.event.inputs.service }}/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ github.event.inputs.service }}:hotfix-${{ github.run_id }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ github.event.inputs.service }}:emergency-latest
          labels: |
            emergency=true
            commit=${{ github.event.inputs.commit_sha }}
            reason=${{ github.event.inputs.reason }}
            actor=${{ github.actor }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-hotfix:
    name: Deploy Hotfix to Production
    runs-on: ubuntu-latest
    needs: build-hotfix
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
      
      - name: Create backup of current deployment
        run: |
          SERVICE=${{ github.event.inputs.service }}
          NAMESPACE=soc-production
          
          # Save current deployment state
          kubectl get deployment ${SERVICE} -n ${NAMESPACE} -o yaml > ${SERVICE}-backup-$(date +%s).yaml
          
          # Get current image
          CURRENT_IMAGE=$(kubectl get deployment ${SERVICE} -n ${NAMESPACE} -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "Current image: $CURRENT_IMAGE"
          echo "PREVIOUS_IMAGE=$CURRENT_IMAGE" >> $GITHUB_ENV
      
      - name: Deploy hotfix
        run: |
          SERVICE=${{ github.event.inputs.service }}
          NAMESPACE=soc-production
          IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${SERVICE}:hotfix-${{ github.run_id }}
          
          # Update deployment with hotfix image
          kubectl set image deployment/${SERVICE} ${SERVICE}=${IMAGE} -n ${NAMESPACE}
          
          # Wait for rollout
          kubectl rollout status deployment/${SERVICE} -n ${NAMESPACE} --timeout=10m
      
      - name: Verify deployment health
        run: |
          SERVICE=${{ github.event.inputs.service }}
          NAMESPACE=soc-production
          
          # Check pod status
          kubectl get pods -l app=${SERVICE} -n ${NAMESPACE}
          
          # Run health check
          POD=$(kubectl get pod -l app=${SERVICE} -n ${NAMESPACE} -o jsonpath='{.items[0].metadata.name}')
          kubectl exec ${POD} -n ${NAMESPACE} -- wget -qO- http://localhost:3000/health || echo "Health check failed"
      
      - name: Update monitoring
        env:
          DD_API_KEY: ${{ secrets.DATADOG_API_KEY }}
          DD_APP_KEY: ${{ secrets.DATADOG_APP_KEY }}
        run: |
          # Create Datadog event
          curl -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "DD-API-KEY: ${DD_API_KEY}" \
            -H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
            -H "Content-Type: application/json" \
            -d '{
              "title": "Emergency Hotfix Deployed",
              "text": "Service: ${{ github.event.inputs.service }}\nReason: ${{ github.event.inputs.reason }}\nCommit: ${{ github.event.inputs.commit_sha }}",
              "priority": "normal",
              "tags": ["environment:production", "service:${{ github.event.inputs.service }}", "type:hotfix"],
              "alert_type": "warning"
            }'

  verify-hotfix:
    name: Verify Hotfix
    runs-on: ubuntu-latest
    needs: deploy-hotfix
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run production smoke tests
        run: |
          # Run targeted tests for the hotfixed service
          cd test/e2e
          npm ci
          npm run test:production:${{ github.event.inputs.service }} || echo "‚ö†Ô∏è Some tests failed"
      
      - name: Monitor error rates
        run: |
          echo "Monitoring error rates for 5 minutes..."
          # This would integrate with your monitoring system
          sleep 300
      
      - name: Decision point
        run: |
          echo "‚úÖ Hotfix deployed successfully"
          echo "Monitor the service closely for the next hour"
          echo "Schedule post-mortem within 48 hours"

  rollback-if-needed:
    name: Rollback if Failed
    runs-on: ubuntu-latest
    needs: [deploy-hotfix, verify-hotfix]
    if: failure()
    
    steps:
      - name: Configure kubectl
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
      
      - name: Rollback deployment
        run: |
          SERVICE=${{ github.event.inputs.service }}
          NAMESPACE=soc-production
          
          echo "üîÑ Rolling back hotfix..."
          kubectl rollout undo deployment/${SERVICE} -n ${NAMESPACE}
          kubectl rollout status deployment/${SERVICE} -n ${NAMESPACE}
      
      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "‚ùå Emergency hotfix failed and was rolled back",
              attachments: [{
                color: 'danger',
                fields: [
                  { title: 'Service', value: '${{ github.event.inputs.service }}', short: true },
                  { title: 'Commit', value: '${{ github.event.inputs.commit_sha }}', short: true },
                  { title: 'Reason', value: '${{ github.event.inputs.reason }}', short: false },
                  { title: 'Action Required', value: 'Investigate failure and prepare new fix', short: false }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  post-deployment:
    name: Post Deployment Tasks
    runs-on: ubuntu-latest
    needs: verify-hotfix
    if: always()
    
    steps:
      - name: Update tracking issue
        uses: actions/github-script@v7
        with:
          script: |
            // Find the tracking issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'emergency,hotfix',
              state: 'open',
              sort: 'created',
              direction: 'desc',
              per_page: 1
            });
            
            if (issues.length > 0) {
              const issue = issues[0];
              
              // Update issue with deployment status
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `### Deployment Update
                
                **Status**: ${{ needs.verify-hotfix.result }}
                **Time**: ${new Date().toISOString()}
                
                ${needs.verify-hotfix.result === 'success' ? '‚úÖ Hotfix deployed successfully' : '‚ùå Hotfix failed and was rolled back'}
                
                ### Next Steps
                1. Monitor service for 1 hour
                2. Create follow-up PR with proper fix
                3. Schedule post-mortem
                4. Update incident documentation`
              });
            }
      
      - name: Schedule post-mortem
        run: |
          echo "üìÖ Post-mortem should be scheduled within 48 hours"
          echo "Include:"
          echo "- Root cause analysis"
          echo "- Timeline of events"
          echo "- Action items to prevent recurrence"
          echo "- Process improvements"
      
      - name: Final notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "Emergency Hotfix Complete",
              attachments: [{
                color: '${{ needs.verify-hotfix.result == 'success' && 'good' || 'danger' }}',
                fields: [
                  { title: 'Service', value: '${{ github.event.inputs.service }}', short: true },
                  { title: 'Result', value: '${{ needs.verify-hotfix.result }}', short: true },
                  { title: 'Deployed By', value: '${{ github.actor }}', short: true },
                  { title: 'Incident', value: '${{ github.event.inputs.incident_id || 'N/A' }}', short: true }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}