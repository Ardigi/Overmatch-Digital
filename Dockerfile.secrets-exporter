# Secrets Monitoring Exporter Dockerfile
FROM node:18-alpine

# Install curl for health checks
RUN apk add --no-cache curl

# Create app directory
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY packages/secrets/package*.json ./packages/secrets/
COPY packages/monitoring/package*.json ./packages/monitoring/

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY packages/secrets ./packages/secrets
COPY packages/monitoring ./packages/monitoring

# Build packages
RUN npm run build --workspace=packages/monitoring
RUN npm run build --workspace=packages/secrets

# Create exporter script
RUN cat > exporter.js << 'EOF'
const express = require('express');
const promClient = require('prom-client');
const { SecretsManagerService } = require('./packages/secrets');
const { MetricsService, SecretsMonitoringService } = require('./packages/monitoring');

const app = express();
const port = process.env.METRICS_PORT || 9090;

// Create metrics registry
const register = new promClient.Registry();

// Initialize metrics service
const metricsService = new MetricsService({
  serviceName: 'secrets-exporter',
  prefix: 'soc_secrets_',
  enableDefaultMetrics: true,
});

// Initialize secrets monitoring
const secretsMonitoring = new SecretsMonitoringService(metricsService);

// Register metrics
metricsService.registerSecretsMetrics();

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  try {
    res.set('Content-Type', register.contentType);
    const metrics = await register.metrics();
    res.end(metrics);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Start background monitoring
setInterval(async () => {
  try {
    // Check Vault health if configured
    if (process.env.VAULT_ADDR) {
      const startTime = Date.now();
      try {
        const response = await fetch(`${process.env.VAULT_ADDR}/v1/sys/health`);
        const isHealthy = response.ok;
        const responseTime = (Date.now() - startTime) / 1000;
        
        secretsMonitoring.recordProviderHealth(
          'hashicorp-vault',
          process.env.VAULT_ADDR,
          isHealthy,
          responseTime
        );
      } catch (error) {
        secretsMonitoring.recordProviderError('hashicorp-vault', 'connection_error');
      }
    }

    // Check AWS Secrets Manager health if configured
    if (process.env.AWS_ENDPOINT_URL) {
      const startTime = Date.now();
      try {
        const response = await fetch(`${process.env.AWS_ENDPOINT_URL}/_localstack/health`);
        const health = await response.json();
        const isHealthy = health.services?.secretsmanager === 'running';
        const responseTime = (Date.now() - startTime) / 1000;
        
        secretsMonitoring.recordProviderHealth(
          'aws-secrets-manager',
          process.env.AWS_ENDPOINT_URL,
          isHealthy,
          responseTime
        );
      } catch (error) {
        secretsMonitoring.recordProviderError('aws-secrets-manager', 'connection_error');
      }
    }

    console.log('Health checks completed');
  } catch (error) {
    console.error('Background monitoring error:', error);
  }
}, parseInt(process.env.CHECK_INTERVAL || '30') * 1000);

app.listen(port, '0.0.0.0', () => {
  console.log(`Secrets monitoring exporter listening on port ${port}`);
});
EOF

# Make the script executable
RUN chmod +x exporter.js

# Expose metrics port
EXPOSE 9090

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:9090/health || exit 1

# Run the exporter
CMD ["node", "exporter.js"]