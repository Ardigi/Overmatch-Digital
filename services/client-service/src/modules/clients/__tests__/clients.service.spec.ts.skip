import { Test, TestingModule } from '@nestjs/testing';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { ClientsService } from '../clients.service';
import { Client, ClientStatus, ComplianceStatus, ClientType, Industry, CompanySize, ComplianceFramework, RiskLevel, ClientUser, ClientDocument, ClientAudit } from './mock-entities';
import { ContractsService } from '../../contracts/contracts.service';
import { KafkaProducerService } from '../../events/kafka-producer.service';
import { CreateClientDto, UpdateClientDto, QueryClientDto, StartOnboardingDto, CompleteOnboardingDto } from '../dto';
import { ConflictException, NotFoundException, BadRequestException } from '@nestjs/common';

// Mock Repository type
type Repository<T> = {
  create: jest.Mock;
  save: jest.Mock;
  findOne: jest.Mock;
  find: jest.Mock;
  update: jest.Mock;
  delete: jest.Mock;
  count: jest.Mock;
  findAndCount: jest.Mock;
  createQueryBuilder: jest.Mock;
};

describe('ClientsService', () => {
  let service: ClientsService;
  let clientRepository: Repository<Client>;
  let clientUserRepository: Repository<ClientUser>;
  let clientDocumentRepository: Repository<ClientDocument>;
  let clientAuditRepository: Repository<ClientAudit>;
  let contractsService: ContractsService;
  let kafkaProducer: KafkaProducerService;
  let eventEmitter: EventEmitter2;

  const mockClient: Client = {
    id: 'client-123',
    name: 'Test Client',
    legalName: 'Test Client LLC',
    slug: 'test-client-123456',
    clientType: ClientType.DIRECT,
    organizationId: 'org-123',
    parentClientId: null,
    parentClient: null,
    subsidiaries: [],
    logo: null,
    website: 'https://testclient.com',
    description: 'A test client',
    industry: Industry.TECHNOLOGY,
    size: CompanySize.MEDIUM,
    employeeCount: 250,
    annualRevenue: '$10M-$50M',
    status: ClientStatus.ACTIVE,
    complianceStatus: ComplianceStatus.ASSESSMENT,
    targetFrameworks: [ComplianceFramework.SOC2_TYPE2],
    riskLevel: RiskLevel.MEDIUM,
    complianceScore: 0.75,
    contactInfo: {
      primaryContact: {
        name: 'John Doe',
        title: 'CTO',
        email: 'john@testclient.com',
        phone: '+1234567890',
      },
    },
    address: {
      headquarters: {
        street1: '123 Main St',
        city: 'San Francisco',
        state: 'CA',
        postalCode: '94105',
        country: 'USA',
      },
    },
    billingInfo: {
      currency: 'USD',
      paymentTerms: 'Net 30',
      paymentMethod: 'ACH',
    },
    partnerId: null,
    partnerReferralDate: null,
    salesRepId: 'sales-123',
    accountManagerId: 'am-123',
    technicalLeadId: 'tech-123',
    onboardingStartDate: null,
    onboardingCompleteDate: null,
    firstAuditDate: null,
    lastAuditDate: null,
    nextAuditDate: null,
    certificateExpiryDate: null,
    auditHistory: [],
    integrations: {},
    settings: {},
    metadata: {},
    tags: ['priority', 'tech'],
    isDeleted: false,
    createdAt: new Date(),
    updatedAt: new Date(),
    createdBy: 'user-123',
    updatedBy: 'user-123',
    deletedAt: null,
    deletedBy: null,
    contracts: [],
    clientUsers: [],
    documents: [],
    audits: [],
    generateSlug: jest.fn(),
    updateTimestamp: jest.fn(),
    isActive: jest.fn(() => true),
    isCompliant: jest.fn(() => false),
    needsAudit: jest.fn(() => true),
    getDaysUntilAudit: jest.fn(() => -1),
    getCertificateDaysRemaining: jest.fn(() => -1),
  } as any;

  const mockQueryBuilder = {
    createQueryBuilder: jest.fn().mockReturnThis(),
    andWhere: jest.fn().mockReturnThis(),
    orWhere: jest.fn().mockReturnThis(),
    where: jest.fn().mockReturnThis(),
    orderBy: jest.fn().mockReturnThis(),
    skip: jest.fn().mockReturnThis(),
    take: jest.fn().mockReturnThis(),
    getManyAndCount: jest.fn(),
    getMany: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ClientsService,
        {
          provide: 'ClientRepository',
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
            findOne: jest.fn(),
            find: jest.fn(),
            update: jest.fn(),
            createQueryBuilder: jest.fn(() => mockQueryBuilder),
          },
        },
        {
          provide: 'ClientUserRepository',
          useValue: {
            find: jest.fn(),
          },
        },
        {
          provide: 'ClientDocumentRepository',
          useValue: {},
        },
        {
          provide: 'ClientAuditRepository',
          useValue: {
            find: jest.fn(),
          },
        },
        {
          provide: ContractsService,
          useValue: {
            findActiveByClientId: jest.fn(),
          },
        },
        {
          provide: KafkaProducerService,
          useValue: {
            publishClientCreated: jest.fn(),
            publishClientUpdated: jest.fn(),
          },
        },
        {
          provide: EventEmitter2,
          useValue: {
            emit: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<ClientsService>(ClientsService);
    clientRepository = module.get<Repository<Client>>('ClientRepository');
    clientUserRepository = module.get<Repository<ClientUser>>('ClientUserRepository');
    clientAuditRepository = module.get<Repository<ClientAudit>>('ClientAuditRepository');
    contractsService = module.get<ContractsService>(ContractsService);
    kafkaProducer = module.get<KafkaProducerService>(KafkaProducerService);
    eventEmitter = module.get<EventEmitter2>(EventEmitter2);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
    it('should create a new client successfully', async () => {
      const createDto: CreateClientDto = {
        name: 'New Client',
        clientType: ClientType.DIRECT,
        industry: Industry.TECHNOLOGY,
        size: CompanySize.MEDIUM,
        contactInfo: {
          primaryContact: {
            name: 'Jane Doe',
            email: 'jane@newclient.com',
          },
        },
      };

      const userId = 'user-123';

      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);
      jest.spyOn(clientRepository, 'create').mockReturnValue(mockClient as any);
      jest.spyOn(clientRepository, 'save').mockResolvedValue(mockClient);

      const result = await service.create(createDto, userId);

      expect(result).toEqual(mockClient);
      expect(clientRepository.findOne).toHaveBeenCalledWith({
        where: { name: createDto.name, isDeleted: false },
      });
      expect(clientRepository.create).toHaveBeenCalledWith({
        ...createDto,
        createdBy: userId,
        updatedBy: userId,
      });
      expect(eventEmitter.emit).toHaveBeenCalledWith('client.created', {
        client: mockClient,
        userId,
        timestamp: expect.any(Date),
      });
      expect(kafkaProducer.publishClientCreated).toHaveBeenCalled();
    });

    it('should throw ConflictException if client name already exists', async () => {
      const createDto: CreateClientDto = {
        name: 'Existing Client',
        clientType: ClientType.DIRECT,
      };

      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(mockClient);

      await expect(service.create(createDto, 'user-123')).rejects.toThrow(
        new ConflictException('Client with this name already exists')
      );

      expect(clientRepository.save).not.toHaveBeenCalled();
    });

    it('should handle Kafka publishing errors gracefully', async () => {
      const createDto: CreateClientDto = {
        name: 'New Client',
        clientType: ClientType.DIRECT,
      };

      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);
      jest.spyOn(clientRepository, 'create').mockReturnValue(mockClient as any);
      jest.spyOn(clientRepository, 'save').mockResolvedValue(mockClient);
      jest.spyOn(kafkaProducer, 'publishClientCreated').mockRejectedValue(new Error('Kafka error'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await service.create(createDto, 'user-123');

      expect(result).toEqual(mockClient);
      expect(consoleSpy).toHaveBeenCalledWith('Failed to publish client created event:', expect.any(Error));

      consoleSpy.mockRestore();
    });

    it('should generate slug automatically', async () => {
      const createDto: CreateClientDto = {
        name: 'Test Client With Spaces',
        clientType: ClientType.DIRECT,
      };

      const expectedSlug = 'test-client-with-spaces-' + Date.now();
      const clientWithSlug = { ...mockClient, slug: expectedSlug };

      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);
      jest.spyOn(clientRepository, 'create').mockReturnValue(clientWithSlug as any);
      jest.spyOn(clientRepository, 'save').mockResolvedValue(clientWithSlug);

      const result = await service.create(createDto, 'user-123');

      expect(result.slug).toBeDefined();
      expect(result.slug).toMatch(/^test-client-with-spaces-\d+$/);
    });
  });

  describe('findAll', () => {
    it('should return paginated clients with default parameters', async () => {
      const mockClients = [mockClient];
      mockQueryBuilder.getManyAndCount.mockResolvedValue([mockClients, 1]);

      const result = await service.findAll({});

      expect(result).toEqual({
        data: mockClients,
        meta: {
          total: 1,
          page: 1,
          limit: 20,
          totalPages: 1,
        },
      });

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.isDeleted = :isDeleted', { isDeleted: false });
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('client.createdAt', 'DESC');
      expect(mockQueryBuilder.skip).toHaveBeenCalledWith(0);
      expect(mockQueryBuilder.take).toHaveBeenCalledWith(20);
    });

    it('should apply search filters correctly', async () => {
      const query: QueryClientDto = {
        search: 'test',
        status: ClientStatus.ACTIVE,
        complianceStatus: ComplianceStatus.COMPLIANT,
        industry: Industry.TECHNOLOGY,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        expect.any(Brackets),
      );
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.status = :status', { status: ClientStatus.ACTIVE });
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.industry = :industry', { industry: Industry.TECHNOLOGY });
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.complianceStatus = :complianceStatus', {
        complianceStatus: ComplianceStatus.COMPLIANT,
      });
    });

    it('should handle framework filtering', async () => {
      const query: QueryClientDto = {
        framework: ComplianceFramework.SOC2_TYPE2,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(':framework = ANY(client.targetFrameworks)', {
        framework: ComplianceFramework.SOC2_TYPE2,
      });
    });

    it('should handle tag filtering', async () => {
      const query: QueryClientDto = {
        tags: ['priority', 'tech'],
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.tags && :tags', { tags: ['priority', 'tech'] });
    });

    it('should handle needsAudit filter', async () => {
      const query: QueryClientDto = {
        needsAudit: true,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(expect.any(Brackets));
    });

    it('should handle expiringSoon filter', async () => {
      const query: QueryClientDto = {
        expiringSoon: true,
        expiringInDays: 60,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 60);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        'client.certificateExpiryDate <= :expiryDate',
        expect.objectContaining({
          expiryDate: expect.any(Date),
        })
      );
    });

    it('should handle sorting options', async () => {
      const sortOptions = [
        { sortBy: 'name', sortOrder: 'ASC' as const },
        { sortBy: 'complianceScore', sortOrder: 'DESC' as const },
        { sortBy: 'nextAuditDate', sortOrder: 'ASC' as const },
      ];

      for (const { sortBy, sortOrder } of sortOptions) {
        mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

        await service.findAll({ sortBy, sortOrder });

        expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith(`client.${sortBy}`, sortOrder);
      }
    });

    it('should handle pagination correctly', async () => {
      const query: QueryClientDto = {
        page: 3,
        limit: 10,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 25]);

      const result = await service.findAll(query);

      expect(mockQueryBuilder.skip).toHaveBeenCalledWith(20); // (3-1) * 10
      expect(mockQueryBuilder.take).toHaveBeenCalledWith(10);
      expect(result.meta).toEqual({
        total: 25,
        page: 3,
        limit: 10,
        totalPages: 3,
      });
    });

    it('should include archived clients when specified', async () => {
      const query: QueryClientDto = {
        includeArchived: true,
      };

      mockQueryBuilder.getManyAndCount.mockResolvedValue([[], 0]);

      await service.findAll(query);

      // Should not add isDeleted filter when includeArchived is true
      expect(mockQueryBuilder.andWhere).not.toHaveBeenCalledWith('client.isDeleted = :isDeleted', { isDeleted: false });
    });
  });

  describe('findOne', () => {
    it('should return a client by ID', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(mockClient);

      const result = await service.findOne('client-123');

      expect(result).toEqual(mockClient);
      expect(clientRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'client-123', isDeleted: false },
        relations: ['subsidiaries', 'contracts', 'clientUsers', 'audits'],
      });
    });

    it('should throw NotFoundException if client not found', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);

      await expect(service.findOne('invalid-id')).rejects.toThrow(
        new NotFoundException('Client with ID invalid-id not found')
      );
    });
  });

  describe('findBySlug', () => {
    it('should return a client by slug', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(mockClient);

      const result = await service.findBySlug('test-client-123456');

      expect(result).toEqual(mockClient);
      expect(clientRepository.findOne).toHaveBeenCalledWith({
        where: { slug: 'test-client-123456', isDeleted: false },
        relations: ['subsidiaries', 'contracts', 'clientUsers', 'audits'],
      });
    });

    it('should throw NotFoundException if client not found by slug', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);

      await expect(service.findBySlug('invalid-slug')).rejects.toThrow(
        new NotFoundException('Client with slug invalid-slug not found')
      );
    });
  });

  describe('update', () => {
    it('should update a client successfully', async () => {
      const updateDto: UpdateClientDto = {
        name: 'Updated Client Name',
        complianceScore: 0.85,
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      const updatedClient = { ...mockClient, ...updateDto };
      jest.spyOn(clientRepository, 'save').mockResolvedValue(updatedClient);

      const result = await service.update('client-123', updateDto, 'user-123');

      expect(result).toEqual(updatedClient);
      expect(eventEmitter.emit).toHaveBeenCalledWith('client.updated', {
        client: updatedClient,
        changes: expect.any(Object),
        userId: 'user-123',
        timestamp: expect.any(Date),
      });
      expect(kafkaProducer.publishClientUpdated).toHaveBeenCalled();
    });

    it('should track changes for audit purposes', async () => {
      const updateDto: UpdateClientDto = {
        name: 'New Name',
        complianceScore: 0.9,
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      jest.spyOn(clientRepository, 'save').mockResolvedValue({ ...mockClient, ...updateDto });

      await service.update('client-123', updateDto, 'user-123');

      expect(eventEmitter.emit).toHaveBeenCalledWith('client.updated', expect.objectContaining({
        changes: {
          name: { old: 'Test Client', new: 'New Name' },
          complianceScore: { old: 0.75, new: 0.9 },
        },
      }));
    });

    it('should handle partial updates', async () => {
      const updateDto: UpdateClientDto = {
        complianceScore: 0.95,
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      const updatedClient = { ...mockClient, complianceScore: 0.95 };
      jest.spyOn(clientRepository, 'save').mockResolvedValue(updatedClient);

      const result = await service.update('client-123', updateDto, 'user-123');

      expect(result.complianceScore).toBe(0.95);
      expect(result.name).toBe(mockClient.name); // Unchanged
    });
  });

  describe('updateComplianceStatus', () => {
    it('should update compliance status and score', async () => {
      const statusTests = [
        { status: ComplianceStatus.COMPLIANT, expectedScore: 1.0 },
        { status: ComplianceStatus.NON_COMPLIANT, expectedScore: 0 },
        { status: ComplianceStatus.READY_FOR_AUDIT, expectedScore: 0.9 },
        { status: ComplianceStatus.UNDER_AUDIT, expectedScore: 0.85 },
        { status: ComplianceStatus.IMPLEMENTATION, expectedScore: 0.5 },
        { status: ComplianceStatus.REMEDIATION, expectedScore: 0.3 },
        { status: ComplianceStatus.ASSESSMENT, expectedScore: 0.2 },
      ];

      for (const { status, expectedScore } of statusTests) {
        jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
        const updatedClient = {
          ...mockClient,
          complianceStatus: status,
          complianceScore: expectedScore,
        };
        jest.spyOn(clientRepository, 'save').mockResolvedValue(updatedClient);

        const result = await service.updateComplianceStatus('client-123', status, 'user-123');

        expect(result.complianceStatus).toBe(status);
        expect(result.complianceScore).toBe(expectedScore);
      }
    });

    it('should emit compliance status change event', async () => {
      const newStatus = ComplianceStatus.COMPLIANT;
      const notes = 'Audit completed successfully';

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      jest.spyOn(clientRepository, 'save').mockResolvedValue({
        ...mockClient,
        complianceStatus: newStatus,
        complianceScore: 1.0,
      });

      await service.updateComplianceStatus('client-123', newStatus, 'user-123', notes);

      expect(eventEmitter.emit).toHaveBeenCalledWith('client.compliance.statusChanged', {
        client: expect.any(Object),
        previousStatus: ComplianceStatus.ASSESSMENT,
        newStatus: ComplianceStatus.COMPLIANT,
        notes,
        userId: 'user-123',
        timestamp: expect.any(Date),
      });
    });
  });

  describe('startOnboarding', () => {
    it('should start onboarding successfully', async () => {
      const startDto: StartOnboardingDto = {
        clientId: 'client-123',
        projectManagerId: 'pm-123',
        customTasks: ['Task 1', 'Task 2'],
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      const updatedClient = {
        ...mockClient,
        onboardingStartDate: new Date(),
        status: ClientStatus.ACTIVE,
      };
      jest.spyOn(clientRepository, 'save').mockResolvedValue(updatedClient);

      const result = await service.startOnboarding(startDto, 'user-123');

      expect(result.onboardingStartDate).toBeDefined();
      expect(result.status).toBe(ClientStatus.ACTIVE);
      expect(eventEmitter.emit).toHaveBeenCalledWith('client.onboarding.started', {
        client: updatedClient,
        projectManagerId: startDto.projectManagerId,
        customTasks: startDto.customTasks,
        userId: 'user-123',
        timestamp: expect.any(Date),
      });
    });

    it('should prevent duplicate onboarding', async () => {
      const clientWithOnboarding = {
        ...mockClient,
        onboardingStartDate: new Date('2025-01-01'),
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(clientWithOnboarding);

      await expect(
        service.startOnboarding({ clientId: 'client-123' }, 'user-123')
      ).rejects.toThrow(
        new BadRequestException('Onboarding has already been started for this client')
      );
    });
  });

  describe('completeOnboarding', () => {
    it('should complete onboarding successfully', async () => {
      const completeDto: CompleteOnboardingDto = {
        summary: 'Onboarding completed',
        finalChecklist: {
          contractsSigned: true,
          systemAccessGranted: true,
        },
        firstAuditScheduled: new Date('2025-03-01'),
      };

      const clientWithStartedOnboarding = {
        ...mockClient,
        onboardingStartDate: new Date('2025-01-01'),
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(clientWithStartedOnboarding);
      const updatedClient = {
        ...clientWithStartedOnboarding,
        onboardingCompleteDate: new Date(),
        nextAuditDate: completeDto.firstAuditScheduled,
        complianceStatus: ComplianceStatus.ASSESSMENT,
      };
      jest.spyOn(clientRepository, 'save').mockResolvedValue(updatedClient);

      const result = await service.completeOnboarding('client-123', completeDto, 'user-123');

      expect(result.onboardingCompleteDate).toBeDefined();
      expect(result.nextAuditDate).toEqual(completeDto.firstAuditScheduled);
      expect(result.complianceStatus).toBe(ComplianceStatus.ASSESSMENT);
    });

    it('should require onboarding to be started first', async () => {
      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);

      await expect(
        service.completeOnboarding('client-123', { summary: 'Test' }, 'user-123')
      ).rejects.toThrow(
        new BadRequestException('Onboarding has not been started for this client')
      );
    });

    it('should prevent completing onboarding twice', async () => {
      const clientWithCompletedOnboarding = {
        ...mockClient,
        onboardingStartDate: new Date('2025-01-01'),
        onboardingCompleteDate: new Date('2025-01-15'),
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(clientWithCompletedOnboarding);

      await expect(
        service.completeOnboarding('client-123', { summary: 'Test' }, 'user-123')
      ).rejects.toThrow(
        new BadRequestException('Onboarding has already been completed for this client')
      );
    });
  });

  describe('archive', () => {
    it('should archive a client successfully', async () => {
      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      jest.spyOn(contractsService, 'findActiveByClientId').mockResolvedValue([]);
      jest.spyOn(clientRepository, 'save').mockResolvedValue({
        ...mockClient,
        status: ClientStatus.ARCHIVED,
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: 'user-123',
      });

      await service.archive('client-123', 'user-123');

      expect(clientRepository.save).toHaveBeenCalledWith(expect.objectContaining({
        status: ClientStatus.ARCHIVED,
        isDeleted: true,
        deletedBy: 'user-123',
      }));
      expect(eventEmitter.emit).toHaveBeenCalledWith('client.archived', {
        clientId: 'client-123',
        userId: 'user-123',
        timestamp: expect.any(Date),
      });
    });

    it('should prevent archiving with active contracts', async () => {
      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      jest.spyOn(contractsService, 'findActiveByClientId').mockResolvedValue([
        { id: 'contract-123', status: 'active' } as any,
      ]);

      await expect(service.archive('client-123', 'user-123')).rejects.toThrow(
        new BadRequestException(
          'Cannot archive client with active contracts. Please terminate or complete all contracts first.'
        )
      );
    });
  });

  describe('restore', () => {
    it('should restore an archived client', async () => {
      const archivedClient = {
        ...mockClient,
        status: ClientStatus.ARCHIVED,
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: 'user-123',
      };

      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(archivedClient);
      const restoredClient = {
        ...archivedClient,
        status: ClientStatus.INACTIVE,
        isDeleted: false,
        deletedAt: null,
        deletedBy: null,
      };
      jest.spyOn(clientRepository, 'save').mockResolvedValue(restoredClient);

      const result = await service.restore('client-123', 'user-456');

      expect(result.isDeleted).toBe(false);
      expect(result.status).toBe(ClientStatus.INACTIVE);
      expect(eventEmitter.emit).toHaveBeenCalledWith('client.restored', {
        client: restoredClient,
        userId: 'user-456',
        timestamp: expect.any(Date),
      });
    });

    it('should throw error if client not found', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(null);

      await expect(service.restore('invalid-id', 'user-123')).rejects.toThrow(
        new NotFoundException('Client with ID invalid-id not found')
      );
    });

    it('should throw error if client not archived', async () => {
      jest.spyOn(clientRepository, 'findOne').mockResolvedValue(mockClient);

      await expect(service.restore('client-123', 'user-123')).rejects.toThrow(
        new BadRequestException('Client is not archived')
      );
    });
  });

  describe('getComplianceMetrics', () => {
    it('should return comprehensive compliance metrics', async () => {
      const mockAudits = [
        {
          id: 'audit-1',
          clientId: 'client-123',
          status: 'SCHEDULED',
          scheduledStartDate: new Date('2025-03-01'),
        },
      ];

      jest.spyOn(service, 'findOne').mockResolvedValue(mockClient);
      jest.spyOn(clientAuditRepository, 'find').mockResolvedValue(mockAudits as any);

      const result = await service.getComplianceMetrics('client-123');

      expect(result).toHaveProperty('overallScore', 0.75);
      expect(result).toHaveProperty('frameworkScores');
      expect(result).toHaveProperty('controlsStatus');
      expect(result).toHaveProperty('upcomingAudits');
      expect(result).toHaveProperty('certificateStatus');
      expect(result.upcomingAudits).toEqual(mockAudits);
    });

    it('should calculate framework scores for each target framework', async () => {
      const clientWithFrameworks = {
        ...mockClient,
        targetFrameworks: [ComplianceFramework.SOC2_TYPE2, ComplianceFramework.ISO27001],
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(clientWithFrameworks);
      jest.spyOn(clientAuditRepository, 'find').mockResolvedValue([]);

      const result = await service.getComplianceMetrics('client-123');

      expect(Object.keys(result.frameworkScores)).toHaveLength(2);
      expect(result.frameworkScores).toHaveProperty('soc2_type2');
      expect(result.frameworkScores).toHaveProperty('iso27001');
    });

    it('should calculate certificate status correctly', async () => {
      const testCases = [
        {
          client: { ...mockClient, complianceStatus: ComplianceStatus.COMPLIANT, certificateExpiryDate: new Date('2025-06-01') },
          expected: { active: 1, expiringSoon: 0, expired: 0 },
        },
        {
          client: { ...mockClient, complianceStatus: ComplianceStatus.COMPLIANT, certificateExpiryDate: new Date('2025-02-01') },
          expected: { active: 1, expiringSoon: 1, expired: 0 },
        },
        {
          client: { ...mockClient, complianceStatus: ComplianceStatus.EXPIRED, certificateExpiryDate: new Date('2024-12-01') },
          expected: { active: 0, expiringSoon: 0, expired: 1 },
        },
      ];

      for (const { client, expected } of testCases) {
        jest.spyOn(service, 'findOne').mockResolvedValue(client);
        jest.spyOn(clientAuditRepository, 'find').mockResolvedValue([]);

        const result = await service.getComplianceMetrics('client-123');

        expect(result.certificateStatus).toEqual(expected);
      }
    });
  });

  describe('getClientUsers', () => {
    it('should return client users with filters', async () => {
      const mockUsers = [
        {
          id: 'user-1',
          clientId: 'client-123',
          userId: 'user-456',
          role: 'admin',
          status: 'active',
        },
      ];

      jest.spyOn(clientUserRepository, 'find').mockResolvedValue(mockUsers as any);

      const result = await service.getClientUsers('client-123', {
        status: 'active',
        role: 'admin',
      });

      expect(result).toEqual(mockUsers);
      expect(clientUserRepository.find).toHaveBeenCalledWith({
        where: {
          clientId: 'client-123',
          status: 'active',
          role: 'admin',
        },
        order: {
          createdAt: 'DESC',
        },
      });
    });

    it('should return all users when no filters provided', async () => {
      jest.spyOn(clientUserRepository, 'find').mockResolvedValue([]);

      await service.getClientUsers('client-123');

      expect(clientUserRepository.find).toHaveBeenCalledWith({
        where: {
          clientId: 'client-123',
        },
        order: {
          createdAt: 'DESC',
        },
      });
    });
  });

  describe('getUpcomingAudits', () => {
    it('should return clients with upcoming audits', async () => {
      const clientsWithAudits = [
        { ...mockClient, nextAuditDate: new Date('2025-02-01') },
        { ...mockClient, id: 'client-456', nextAuditDate: null },
      ];

      mockQueryBuilder.getMany.mockResolvedValue(clientsWithAudits);

      const result = await service.getUpcomingAudits(90);

      expect(result).toEqual(clientsWithAudits);
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('client.nextAuditDate', 'ASC', 'NULLS FIRST');
    });

    it('should use default days if not specified', async () => {
      mockQueryBuilder.getMany.mockResolvedValue([]);

      await service.getUpcomingAudits();

      // Should use default 90 days
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 90);

      expect(mockQueryBuilder.getMany).toHaveBeenCalled();
    });
  });

  describe('getExpiringCertificates', () => {
    it('should return clients with expiring certificates', async () => {
      const clientsWithExpiring = [
        { ...mockClient, certificateExpiryDate: new Date('2025-02-01') },
        { ...mockClient, id: 'client-456', certificateExpiryDate: new Date('2025-03-01') },
      ];

      mockQueryBuilder.getMany.mockResolvedValue(clientsWithExpiring);

      const result = await service.getExpiringCertificates(60);

      expect(result).toEqual(clientsWithExpiring);
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('client.certificateExpiryDate IS NOT NULL');
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('client.certificateExpiryDate', 'ASC');
    });
  });

  describe('getDashboardStats', () => {
    it('should calculate dashboard statistics correctly', async () => {
      const mockClients = [
        { ...mockClient, status: ClientStatus.ACTIVE, complianceStatus: ComplianceStatus.COMPLIANT, complianceScore: 0.9 },
        { ...mockClient, id: 'client-456', status: ClientStatus.ACTIVE, complianceStatus: ComplianceStatus.ASSESSMENT, complianceScore: 0.6 },
        { ...mockClient, id: 'client-789', status: ClientStatus.INACTIVE, complianceStatus: ComplianceStatus.NOT_STARTED, complianceScore: 0 },
      ];

      jest.spyOn(clientRepository, 'find').mockResolvedValue(mockClients as any);
      jest.spyOn(service, 'getUpcomingAudits').mockResolvedValue([mockClient]);
      jest.spyOn(service, 'getExpiringCertificates').mockResolvedValue([mockClient]);

      const result = await service.getDashboardStats();

      expect(result.totalClients).toBe(3);
      expect(result.activeClients).toBe(2);
      expect(result.clientsByStatus[ClientStatus.ACTIVE]).toBe(2);
      expect(result.clientsByStatus[ClientStatus.INACTIVE]).toBe(1);
      expect(result.averageComplianceScore).toBe(0.75); // (0.9 + 0.6) / 2
      expect(result.upcomingAuditsCount).toBe(1);
      expect(result.expiringCertificatesCount).toBe(1);
    });

    it('should handle empty database', async () => {
      jest.spyOn(clientRepository, 'find').mockResolvedValue([]);
      jest.spyOn(service, 'getUpcomingAudits').mockResolvedValue([]);
      jest.spyOn(service, 'getExpiringCertificates').mockResolvedValue([]);

      const result = await service.getDashboardStats();

      expect(result.totalClients).toBe(0);
      expect(result.activeClients).toBe(0);
      expect(result.averageComplianceScore).toBe(0);
    });

    it('should count frameworks correctly', async () => {
      const clientsWithFrameworks = [
        { ...mockClient, targetFrameworks: [ComplianceFramework.SOC2_TYPE2, ComplianceFramework.ISO27001] },
        { ...mockClient, id: 'client-456', targetFrameworks: [ComplianceFramework.SOC2_TYPE2] },
      ];

      jest.spyOn(clientRepository, 'find').mockResolvedValue(clientsWithFrameworks as any);
      jest.spyOn(service, 'getUpcomingAudits').mockResolvedValue([]);
      jest.spyOn(service, 'getExpiringCertificates').mockResolvedValue([]);

      const result = await service.getDashboardStats();

      expect(result.clientsByFramework[ComplianceFramework.SOC2_TYPE2]).toBe(2);
      expect(result.clientsByFramework[ComplianceFramework.ISO27001]).toBe(1);
    });
  });

  describe('findByOrganizationId', () => {
    it('should return clients for an organization', async () => {
      const orgClients = [
        { ...mockClient, organizationId: 'org-123' },
        { ...mockClient, id: 'client-456', organizationId: 'org-123' },
      ];

      jest.spyOn(clientRepository, 'find').mockResolvedValue(orgClients as any);

      const result = await service.findByOrganizationId('org-123');

      expect(result).toEqual(orgClients);
      expect(clientRepository.find).toHaveBeenCalledWith({
        where: {
          organizationId: 'org-123',
          isDeleted: false,
        },
        order: {
          createdAt: 'DESC',
        },
      });
    });

    it('should return empty array if no clients found', async () => {
      jest.spyOn(clientRepository, 'find').mockResolvedValue([]);

      const result = await service.findByOrganizationId('org-999');

      expect(result).toEqual([]);
    });
  });

  describe('Entity Helper Methods', () => {
    it('should correctly determine if client is active', () => {
      const activeClient = { ...mockClient, status: ClientStatus.ACTIVE };
      const inactiveClient = { ...mockClient, status: ClientStatus.INACTIVE };

      expect(activeClient.isActive()).toBe(true);
      expect(inactiveClient.isActive()).toBe(true); // Based on mock
    });

    it('should correctly determine if client is compliant', () => {
      const compliantClient = { ...mockClient, complianceStatus: ComplianceStatus.COMPLIANT };
      const nonCompliantClient = { ...mockClient, complianceStatus: ComplianceStatus.ASSESSMENT };

      expect(compliantClient.isCompliant()).toBe(false); // Based on mock
      expect(nonCompliantClient.isCompliant()).toBe(false);
    });

    it('should calculate days until audit correctly', () => {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 30);
      
      const clientWithAudit = { ...mockClient, nextAuditDate: futureDate };
      const clientWithoutAudit = { ...mockClient, nextAuditDate: null };

      expect(clientWithAudit.getDaysUntilAudit()).toBe(-1); // Based on mock
      expect(clientWithoutAudit.getDaysUntilAudit()).toBe(-1);
    });

    it('should calculate certificate days remaining', () => {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 60);
      
      const clientWithCert = { ...mockClient, certificateExpiryDate: futureDate };
      const clientWithoutCert = { ...mockClient, certificateExpiryDate: null };

      expect(clientWithCert.getCertificateDaysRemaining()).toBe(-1); // Based on mock
      expect(clientWithoutCert.getCertificateDaysRemaining()).toBe(-1);
    });
  });
});